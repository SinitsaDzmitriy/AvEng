    The request resulting from a typical form submission is simple and takes the
form of multiple name-value pairs separated by ampersands:
    firstVar=firstVal&secondVar=secondVal

    to result from - происходить в результате чего-либо

    Although this encoding scheme is simple and sufficient for typical text-based
form submissions, it isn’t robust enough to carry binary data such as an uploaded
image.

    sufficient - достаточный
    robust - надежный, прочный

    Multipart data breaks a form into individual parts, with one part per field.
Each part can have its own type (typical textual data). But when sth is being
uploaded, the part can be binary, as shown in the following multipart request
body:
    ------WebKitFormBoundaryqgkaBn8IHJCuNmiW
    Content-Disposition: form-data; name="textualData"
    Text
    ------WebKitFormBoundaryqgkaBn8IHJCuNmiW
    Content-Disposition: form-data; name="numericData"
    0
    ------WebKitFormBoundaryqgkaBn8IHJCuNmiW
    Content-Disposition: form-data; name="picture"; filename="picture.jpg"
    Content-Type: image/jpeg
    [[ Binary image data goes here ]]
    ------WebKitFormBoundaryqgkaBn8IHJCuNmiW--

    multipart - составной, состоящий из нескольких частей
    with ... per ... - по ... на каждый ... (по одной части на каждое поле)

    In this multipart request, the picture part is noticeably different from the
other parts. Among other things, it has its own Content-Type header indicating
that it’s a JPEG image. And although it may not be obvious, the body of the
picture part is binary data instead of simple text.

    noticeably - заметно, значительно

    It's easy to handle multipart requests in a Spring MVC controller. But before
writing controller methods to handle file uploads, a multipart resolver has to be
configured to tell DispatcherServlet how to read multipart requests.

    -- Configuring a Multipart Resolver

    DispatcherServlet doesn’t implement any logic for parsing the data in a
multipart request. Instead, it delegates to an implementation of Spring’s
MultipartResolver strategy interface to resolve the content in a multipart
request. Since Spring 3.1, Spring comes with two out-of-the-box implementations
of MultipartResolver to choose from:
    -   CommonsMultipartResolver — Resolves multipart requests using Jakarta
        Commons FileUpload
    -   StandardServletMultipartResolver — Relies on Servlet 3.0 support for
        multipart requests (since Spring 3.1)

    Generally speaking, StandardServletMultipartResolver should probably be your
first choice of these two. It uses existing support in your servlet container and
doesn’t require any additional project dependencies.

    generally speaking - вообще говоря
    firs choice - оптимальный, наилучший, главный

    Commons MultipartResolver might be used if app is deployed to a pre-Servlet
3.0 container or Spring 3.1 or higher hasn't been used yet.

    -- Resolving Multipart Requests With Servlet 3.0

    The Servlet 3.0-compatible StandardServletMultipartResolver has no
constructor arguments or properties to be set. This makes it extremely simple to
declare as a bean Spring configuration:

    @Bean
    public MultipartResolver multipartResolver() throws IOException {
        return new StandardServletMultipartResolver();
    }

    How can constraints be placed on the way StandardServletMultipartResolver
works?
    How to limit the max size of file that user can upload?
    How to specify the location where the uploaded files are temporarily written
while they’re being uploaded?

    temporarily - временно

    It has no properties and no constructor arguments

    Despite of the fact that it has no properties and no constructor arguments,
it’s possible to configure constraints on StandardServletMultipartResolver.
Instead of configuring StandardServletMultipartResolver in Spring configuration,
multipart configuration must be specified in the servlet configuration. At the
very leas, file path where the file will be written during the upload must be
specified. StandardServletMultipartResolver won’t work unless this minimum detail
will be configure. More specifically, you must configure multipart details as
part of DispatcherServlet’s configuration in web.xml or in the servlet
initializer class.

    At the very least, ... - Самое меньшее, ... По крайней мере, ...
    More specifically, ... - Говоря конкретнее, ...
    a dispatcher - дисетчер

    If DispatcherServlet is being configured in a servlet initializer class that
implements AbstractAnnotationConfigDispatcherServletInitializer, the instance of
DispatcherServlet doesn’t created or registered with the servlet context
directly. Consequently, there’s no handy reference to the Dynamic servlet
registration to work with. But the customizeRegistration() method which is given
a Dynamic as a parameter can be overridden to configure multipart details:

    @Override
    protected void customizeRegistration(Dynamic registration) {
        registration
            .setMultipartConfig(new MultipartConfigElement("/tmp/uploads"));
    }

    Consequently, ... - следовательно
    handy - удобный, легко управляемый
    to customize - настраивать

===============================================================================

    (1)
    customizeRegistration(ServletRegistration.Dynamic registration)

    Optionally perform further registration customization once
registerDispatcherServlet(ServletContext) has completed.

    optionally - необязательно, по желанию.
    once - как только.

    (2)
    registerDispatcherServlet(ServletContext)

    Register (create and initialize) a DispatcherServlet against the given
servlet context.

    against - на, согласно

    (3)
    ServletRegistration.Dynamic
    Interface through which a Servlet registered via one of the addServlet
methods on ServletContext may be further configured.

===============================================================================

    The single-argument constructor for MultipartConfigElement takes the absolute
path to a directory in the filesystem where the uploaded file will be written
temporarily. But there’s another constructor that lets you set a few constraints
on the size of the file being uploaded. In addition to the temporary location
path, the other constructor accepts the following:
    -   The maximum size (in bytes) of any file uploaded. By default there is no
limit.
    -   The maximum size (in bytes) of the entire multipart request, regardless
of how many parts or how big any of the parts are. By default there is no limit.
    -   The maximum size (in bytes) of a file that can be uploaded without being
written to the temporary location. The default is 0, meaning that all uploaded
files will be written to disk.

    @Override
    protected void customizeRegistration(Dynamic registration) {
        registration
            .setMultipartConfig(new MultipartConfigElement("/tmp/uploads",
                2097152, 4194304, 0));
    }

    thus far - до сих пор
    regardless of - не обращая внимания на

    -- Handling Multipart Requests

    The most common way of writing a controller method which accepts the uploaded
file is to annotate its parameter with @RequestPart.
    A form must be created so that the user can select a (audio) file to be
uploaded, and the processRegistration() method must be tweaked in a controller
to accept the uploaded file. The following snippet (plain HTML) highlights the
necessary form parts:

    so that - чтобы
    to tweak - настроить
    a snippet - отрывок, кусок фрагмент

    <html>

        <head>
            <title>Upload a file please</title>
        </head>

        <body>
            <h1>Please upload a file</h1>

            <form method="post" action="/form" enctype="multipart/form-data">
                <input type="text" name="name"/>
                <input type="file" accept=".extension" name="uploadedFile"/>
                <input type="submit"/>
            </form>

        </body>

    </html>

===============================================================================

    The <form> tag is used to create an HTML form for user input.
    Attributes:

    - method
    Specifies the HTTP method to use when sending form-data.
    Values: get, post.

    - action
    Specifies (URL) where to send the form-data when a form is submitted.

    - enctype
    Specifies how the form-data should be encoded when submitting it to the
server (only for method="post").
    Values:
    text/plain
    multipart/form-data
    application/x-www-form-urlencoded
    ToDO: get more about the options

    - accept
    The accept attribute specifies a filter for what file types the user can
pick from the file input dialog box (only for type="file").
    The truth is that the 'accept' attribute just provides a filter in the file
select dialog box of the OS, but doesn't prevent the user from choosing files
of any type or extension. Therefore, it's not a validation tool. File uploads
should be validated on the server.

    to prevent from - предохранять от, препятствовать

    Attribute Values

    value: file_extension
    descr: specify the file extension (.gif) the user can pick from

    value: audio/*
    descr: the user can pick all sound files

    value: video/*
    descr: the user can pick all video files

    value: image/*
    descr: the user can pick all image files

    value: media_type
    descr: a valid media type, there is a list of standard media types

===============================================================================

    The enctype attribute of the <form> tag setting to multipart/form-data tells
the browser to submit the form as multipart data instead of form data. Each field
has its own part in the multipart request.
    A new <input> field whose type is file has been added. This lets the user
select a file to upload. The 'accept' attribute is set to limit file types. And
according to its 'name' attribute, the file data will be sent in the multipart
request in the uploadedFile part.
    Now a method in a Controller must be created to accept the uploaded file.
One way to do that is to add a byte array parameter that’s annotated with
@RequestPart.

    @RequestMapping(method=POST)
    public String processRegistration(@RequestPart("file") byte[] fileInBytes) {
        ...
        return "redirect:/some/url";
    }

    When the registration form is submitted, the fileInBytes parameter is given
an array of byte containing the data from the request part specified by name in
a @RequestPart annotation. If the user submits the form without selecting a file,
then the array will be empty (but not null). All that’s left is to save the file
somewhere.

    -- MultipartFile

    Working with the uploaded file’s raw bytes is simple but limiting. Therefore,
Spring also offers MultipartFile as a way to get a richer object for processing
multipart data. The following listing shows what the MultipartFile interface
looks like.

    public interface MultipartFile {
        String getName();
        String getOriginalFilename();
        String getContentType();
        boolean isEmpty();
        long getSize();
        byte[] getBytes() throws IOException;
        InputStream getInputStream() throws IOException;
        void transferTo(File dest) throws IOException;
    }

    As you can see, MultipartFile offers a way to get at the bytes for the
uploaded file. But it offers much more, including the original filename, size,
and content type. It also offers an InputStream for reading the file data as
a stream.
    What’s more, MultipartFile offers a convenient transferTo() method to help
you write the uploaded file to the filesystem. For example, you could add the
following lines to write the uploaded file to the filesystem:

    file.transferTo(new File("C:/tmp" + file.getOriginalFilename()));

    Saving a file to the local filesystem like this is simple enough, but it
leaves the management of the file up to developer. They’re responsible for
ensuring that there’s plenty of space. It’s up to they to make sure the file
is backed up in case of a hardware failure. And it’s their job to deal with
synchronizing the files across multiple servers in a cluster.

    to be up to sb - зависить от кого-либо
    to ensure - гарнтировать
    plenty - достаточно, довольно
    to back up - резервно копировать